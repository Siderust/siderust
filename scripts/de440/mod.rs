// SPDX-License-Identifier: AGPL-3.0-or-later
// Copyright (C) 2026 Vallés Puig, Ramon

//! DE440 build-time pipeline: download → parse DAF/SPK → extract segments → codegen.
//!
//! Only activated when the `de440` Cargo feature is enabled.

mod daf;
mod fetch;
mod spk;

use std::path::Path;

/// NAIF body IDs for the segments we extract.
const SUN_ID: i32 = 10;
const EMB_ID: i32 = 3;
const MOON_ID: i32 = 301;

/// Bodies to extract: (target_id, center_id, output_name)
const BODIES: &[(i32, i32, &str)] = &[
    (SUN_ID, 0, "sun"),
    (EMB_ID, 0, "emb"),
    (MOON_ID, EMB_ID, "moon"),
];

/// Run the DE440 build pipeline.
///
/// 1. Download `de440.bsp` (if not cached).
/// 2. Parse the DAF container → SPK segment summaries.
/// 3. For each requested body, read coefficient records.
/// 4. Write compact binary files + a Rust accessor module.
pub fn run(data_dir: &Path) -> anyhow::Result<()> {
    let out_dir =
        std::path::PathBuf::from(std::env::var("OUT_DIR").expect("OUT_DIR not set by Cargo"));

    // 1. Fetch
    let bsp_path = fetch::ensure_bsp(data_dir)?;
    eprintln!("  DE440 BSP at: {}", bsp_path.display());

    // 2. Parse DAF
    let file_data = std::fs::read(&bsp_path)?;
    let daf = daf::Daf::parse(&file_data)?;
    eprintln!(
        "  DAF parsed: {} summaries, ND={}, NI={}",
        daf.summaries.len(),
        daf.nd,
        daf.ni
    );

    // 3. Extract bodies → binary files + codegen
    let mut generated_bodies: Vec<(&str, spk::SegmentMeta)> = Vec::new();

    for &(target, center, name) in BODIES {
        let summary = daf
            .summaries
            .iter()
            .find(|s| s.target_id == target && s.center_id == center)
            .unwrap_or_else(|| {
                panic!(
                    "DE440: segment target={} center={} not found in BSP",
                    target, center
                )
            });

        eprintln!(
            "  Segment {}: target={}, center={}, type={}, records at words {}..{}",
            name,
            summary.target_id,
            summary.center_id,
            summary.data_type,
            summary.start_word,
            summary.end_word
        );

        assert!(
            summary.data_type == 2 || summary.data_type == 3,
            "DE440: only SPK Type 2/3 supported, got Type {}",
            summary.data_type
        );

        let meta = spk::read_type2_segment(&file_data, &daf, summary)?;
        eprintln!(
            "    ncoeff={}, n_records={}, intlen={:.1}s ({:.1} days), rsize={}",
            meta.ncoeff,
            meta.n_records,
            meta.intlen,
            meta.intlen / 86400.0,
            meta.rsize
        );

        // Write binary data file
        let bin_path = out_dir.join(format!("de440_{}.bin", name));
        spk::write_binary(&meta, &bin_path)?;
        eprintln!(
            "    → {} ({} bytes)",
            bin_path.display(),
            std::fs::metadata(&bin_path)?.len()
        );

        generated_bodies.push((name, meta));
    }

    // 4. Generate Rust accessor module
    let rs_path = out_dir.join("de440_data.rs");
    generate_rust_module(&generated_bodies, &rs_path)?;
    eprintln!("  → {}", rs_path.display());

    Ok(())
}

/// Generate the Rust source that includes the binary data and exposes typed accessors.
fn generate_rust_module(bodies: &[(&str, spk::SegmentMeta)], path: &Path) -> anyhow::Result<()> {
    use std::io::Write;
    let mut f = std::fs::File::create(path)?;
    writeln!(f, "// AUTOGENERATED by build.rs — do not edit")?;
    writeln!(f, "// DE440 embedded Chebyshev coefficient data")?;
    writeln!(f)?;

    for (name, meta) in bodies {
        let upper = name.to_uppercase();
        let byte_count = meta.n_records * meta.rsize * 8;

        writeln!(f, "/// DE440 Chebyshev data for body `{}`.", name)?;
        writeln!(f, "pub mod {} {{", name)?;
        writeln!(f, "    /// Initial epoch (TDB seconds past J2000).")?;
        writeln!(f, "    pub const INIT: f64 = {:?};", meta.init)?;
        writeln!(f, "    /// Interval length (seconds).")?;
        writeln!(f, "    pub const INTLEN: f64 = {:?};", meta.intlen)?;
        writeln!(
            f,
            "    /// Number of Chebyshev coefficients per coordinate."
        )?;
        writeln!(f, "    pub const NCOEFF: usize = {};", meta.ncoeff)?;
        writeln!(f, "    /// Doubles per record (2 + 3 * NCOEFF).")?;
        writeln!(f, "    pub const RSIZE: usize = {};", meta.rsize)?;
        writeln!(f, "    /// Number of records.")?;
        writeln!(f, "    pub const N_RECORDS: usize = {};", meta.n_records)?;
        writeln!(f)?;
        writeln!(f, "    /// Total byte count of the binary data.")?;
        writeln!(f, "    const BYTE_COUNT: usize = {};", byte_count)?;
        writeln!(f)?;
        writeln!(
            f,
            "    /// 8-byte aligned wrapper for `include_bytes!` data."
        )?;
        writeln!(f, "    #[repr(C, align(8))]")?;
        writeln!(f, "    struct Aligned([u8; BYTE_COUNT]);")?;
        writeln!(f)?;
        writeln!(
            f,
            "    /// Raw coefficient data, embedded with 8-byte alignment."
        )?;
        writeln!(
            f,
            "    static DATA: &Aligned = &Aligned(*include_bytes!(concat!(env!(\"OUT_DIR\"), \"/de440_{}.bin\")));",
            name
        )?;
        writeln!(f)?;
        writeln!(
            f,
            "    /// Return the `i`-th record as a slice of `RSIZE` f64 values."
        )?;
        writeln!(f, "    #[inline]")?;
        writeln!(f, "    pub fn record(i: usize) -> &'static [f64] {{")?;
        writeln!(f, "        debug_assert!(i < N_RECORDS, \"DE440 {}: record index {{}} out of range (max {{}})\", i, N_RECORDS - 1);", upper)?;
        writeln!(f, "        let byte_offset = i * RSIZE * 8;")?;
        writeln!(f, "        let ptr = DATA.0.as_ptr();")?;
        writeln!(
            f,
            "        // SAFETY: `DATA` is #[repr(align(8))] so `ptr` is 8-byte aligned."
        )?;
        writeln!(
            f,
            "        // Each record starts at a multiple of RSIZE*8 bytes (also aligned)."
        )?;
        writeln!(
            f,
            "        // The binary data was written as native-endian f64 by the build script."
        )?;
        writeln!(f, "        unsafe {{")?;
        writeln!(
            f,
            "            std::slice::from_raw_parts(ptr.add(byte_offset) as *const f64, RSIZE)"
        )?;
        writeln!(f, "        }}")?;
        writeln!(f, "    }}")?;
        writeln!(f, "}}")?;
        writeln!(f)?;
    }

    Ok(())
}
