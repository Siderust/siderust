//! build.rs – Processes **all** VSOP87A.* and VSOP87E.* files in the
//! `dataset/` directory, generates a .bin + .o per file, and a Rust
//! wrapper with functions like `vsop87e_mar_terms()`.
//!
//! • Requires `GNU/LLVM objcopy` and crates: anyhow, regex, walkdir.

use anyhow::{bail, Context, Result};
use regex::Regex;
use std::{
    env,
    fs::{self, File},
    io::{BufRead, BufReader, Write},
    path::PathBuf,
    process::Command,
};
use walkdir::WalkDir;

// ---------------------------------------------------------------------
// Internal Structure
// ---------------------------------------------------------------------
#[repr(C)]
#[derive(Debug, Clone, Copy)]
struct Vsop87 {
    a: f64,
    b: f64,
    c: f64,
}

// ---------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------
const DATA_DIR: &str = "dataset";
const REGEX_FILE: &str = r"^VSOP87[AE]\.[A-Za-z]{3}$";          // e.g. VSOP87A.mar
const HEADER_REGEX: &str =
    r"VSOP87 VERSION [A-Z]?\d+\s+(\S+)\s+VARIABLE\s+(\d+)\s+\(XYZ\)\s+\*T\*\*(\d+)\s+(\d+)\s+TERMS";

fn main() -> Result<()> {
    let file_re = Regex::new(REGEX_FILE)?;
    let header_re = Regex::new(HEADER_REGEX)?;

    let target_os   = env::var("CARGO_CFG_TARGET_OS")?;
    let target_arch = env::var("CARGO_CFG_TARGET_ARCH")?;
    let (fmt, arch) = match (target_os.as_str(), target_arch.as_str()) {
        ("windows", "x86_64") => ("pe-x86-64", "i386:x86-64"),
        ("windows", "aarch64") => ("pe-arm64",  "aarch64"),
        ("macos",   "x86_64") => ("mach-o",     "i386:x86-64"),
        ("macos",   "aarch64")=> ("mach-o",     "aarch64"),
        ("linux",   "x86_64") => ("elf64-x86-64","i386:x86-64"),
        ("linux",   "aarch64")=> ("elf64-aarch64","aarch64"),
        (os, arch) => bail!("Unsupported target {os}/{arch}"),
    };

    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    let mut wrappers = String::from(
        "// ---------- auto-generated by build.rs ----------\n\
         use bytemuck::{cast_slice, Pod, Zeroable};\n\n\
         #[repr(C)]\n#[derive(Clone, Copy, Debug, Pod, Zeroable)]\n\
         pub struct Vsop87 { pub a: f64, pub b: f64, pub c: f64 }\n\n"
    );

    // Re-run if anything in the directory changes
    println!("cargo:rerun-if-changed={DATA_DIR}");
    println!("cargo:rerun-if-changed=build.rs");

    // -----------------------------------------------------------------
    // Iterate over all VSOP87A / VSOP87E files
    // -----------------------------------------------------------------
    for entry in WalkDir::new(DATA_DIR).min_depth(1).into_iter().filter_map(Result::ok) {
        let path = entry.path();
        let fname = path.file_name().unwrap().to_string_lossy();
        if !file_re.is_match(&fname) { continue; }

        println!("cargo:info=Processing {fname}");

        // ---------- 1) Parse ------------------------------------------------
        let mut terms: Vec<Vsop87> = Vec::new();
        let file = BufReader::new(File::open(path)?);

        let (mut _planet, mut _coord, mut _tpow, mut _left) =
            (String::new(), 0u8, 0u8, 0usize);

        for line in file.lines() {
            let line = line?;
            if let Some(c) = header_re.captures(&line) {
                _planet = c[1].to_uppercase();
                _coord  = c[2].parse()?;
                _tpow   = c[3].parse()?;
                _left   = c[4].parse()?;
                continue;
            }
            if _left == 0 { continue; }

            let parts: Vec<_> = line.split_whitespace().collect();
            if parts.len() < 5 { continue; }

            let s: f64 = parts[parts.len()-5].parse()?;
            let k: f64 = parts[parts.len()-4].parse()?;
            let a: f64 = parts[parts.len()-3].parse()?;
            let b: f64 = parts[parts.len()-2].parse()?;
            let c: f64 = parts[parts.len()-1].parse()?;

            if a.abs() > 1e-15 {
                terms.push(Vsop87{a,b,c});
            } else if s.abs() > 1e-15 || k.abs() > 1e-15 {
                let r = s.hypot(k);
                let alpha = s.atan2(k);
                terms.push(Vsop87 { a: r, b: b - alpha, c });
            }
            _left -= 1;
        }

        // ---------- 2) Write .bin ----------------------------------------
        let stem = fname.to_ascii_lowercase().replace('.', "_");   // vsop87e_mar
        let bin_path = out_dir.join(format!("{stem}.bin"));
        let mut bin = File::create(&bin_path)?;
        for t in &terms {
            bin.write_all(&t.a.to_le_bytes())?;
            bin.write_all(&t.b.to_le_bytes())?;
            bin.write_all(&t.c.to_le_bytes())?;
        }
        bin.flush()?;

        // ---------- 3) objcopy → .o -----------------------------------------
        let obj_path = out_dir.join(format!("{stem}.o"));
        let status = Command::new("objcopy")
            .args([
                "-I","binary","-O",fmt,"--binary-architecture",arch,
                bin_path.to_str().unwrap(),
                obj_path.to_str().unwrap(),
            ])
            .status()
            .context("running objcopy")?;
        if !status.success() { bail!("objcopy failed for {fname}"); }

        println!("cargo:rustc-link-arg={}", obj_path.display());

        // ---------- 4) Generate Rust wrapper ---------------------------------
        wrappers.push_str(&format!(
            "extern \"C\" {{\n    static _binary_{stem}_bin_start: u8;\n    \
             static _binary_{stem}_bin_end:   u8;\n}}\n\n\
             #[inline] pub fn {stem}_terms() -> &'static [Vsop87] {{\n    \
             unsafe {{\n        let start = &_binary_{stem}_bin_start as *const u8 as usize;\n        \
             let end   = &_binary_{stem}_bin_end   as *const u8 as usize;\n        \
             let bytes = std::slice::from_raw_parts(start as *const u8, end-start);\n        \
             cast_slice(bytes)\n    }}\n}}\n\n"
        ));
    }

    // ---------- 5) Write wrapper to OUT_DIR ------------------------------
    fs::write(out_dir.join("vsop_tables.rs"), wrappers)
        .context("writing vsop_tables.rs")?;

    Ok(())
}
