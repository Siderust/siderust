#!/usr/bin/env python3
import math
import re

# -----------------------------------------------
# Generated by parse_Vsop87.py
# -----------------------------------------------
# This script reads a Vsop87 data file (version A) and outputs Rust
# code that defines static arrays for each planetâ€™s expansions.
# It converts rows of data into Rust code that looks like:
#   pub static VENUS_X0: [Vsop87; N] = [ Vsop87 { a: ..., b: ..., c: ... }, ... ];
# 
# The script has been modified so that if the direct term (A) is provided,
# it uses that and does not add an extra term from S/K.
# Also, if a coefficient is an integer (like 0) it is formatted with a decimal point (e.g., 0.0).

# 1) Rust header string.
RUST_HEADER = r"""// -----------------------------------------------
// Generated by parse_Vsop87.py
// -----------------------------------------------
use crate::calculus::vsop87::Vsop87;
"""

# 2) Data structure to hold a single Vsop87 term.
class Vsop87:
    """Represents a single (a, b, c) term for the final 'a cos(b + c T)'."""
    __slots__ = ("a", "b", "c")
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def __repr__(self):
        # Use the helper function format_float to ensure that integer values like 0 are printed as 0.0
        return f"Vsop87 {{ a: {format_float(self.a)}, b: {format_float(self.b)}, c: {format_float(self.c)} }}"

def format_float(val):
    """Formats the float so that whole numbers appear with a decimal (e.g., 0 -> 0.0)."""
    # Check if the value is nearly an integer
    if abs(val - round(val)) < 1e-15:
        return f"{val:.1f}"
    else:
        return f"{val:.14g}"

# We'll store expansions in a nested dictionary:
# expansions[planet][coord][t_power] = list of Vsop87 objects.
# 'planet' is a string (e.g., "VENUS")
# 'coord' is an integer 1..3 corresponding to X, Y, Z.
# 't_power' is an integer 0..5.
expansions = {}

def ensure_path(planet, coord, t_power):
    """Ensure expansions[planet][coord][t_power] exists."""
    if planet not in expansions:
        expansions[planet] = {}
    if coord not in expansions[planet]:
        expansions[planet][coord] = {}
    if t_power not in expansions[planet][coord]:
        expansions[planet][coord][t_power] = []

# 3) Regex to detect header lines.
# Example header line:
# "Vsop87 VERSION A1    VENUS     VARIABLE 1 (XYZ)       *T**0    548 TERMS    HELIOCENTRIC DYNAMICAL ECLIPTIC AND EQUINOX J2000"
header_re = re.compile(
    r"Vsop87 VERSION [A-Z]?\d+\s+(\S+)\s+VARIABLE\s+(\d+)\s+\(XYZ\)\s+\*T\*\*(\d+)\s+(\d+)\s+TERMS",
    re.IGNORECASE
)

def parse_Vsop87_line(line):
    """
    Given a line like:
      1210    1  0  1  0  0  0  0  0  0  0  0  0  0  0.00028042043 0.72211275946 0.72211281391 3.17575836361 10213.28554621100
    Parse out the last five numbers: S, K, A, B, C.
    Returns a tuple (S, K, A, B, C) or None if parsing fails.
    """
    parts = line.split()
    if len(parts) < 5:
        return None
    try:
        # The last five fields are S, K, A, B, C.
        c_val = float(parts[-1])
        b_val = float(parts[-2])
        a_val = float(parts[-3])
        k_val = float(parts[-4])
        s_val = float(parts[-5])
        return (s_val, k_val, a_val, b_val, c_val)
    except ValueError:
        return None

def convert_sk_to_cos(S, K, A, B, C):
    """
    Convert one line's data into one (or sometimes two) Vsop87 term(s).
    
    Logic:
      - If A is provided (nonzero), use it and ignore S/K.
      - Only if A is negligible, convert S sin(...) + K cos(...)
        into a single cosine term.
    """
    terms = []
    # If A is nonzero, use the direct term.
    if abs(A) > 1e-15:
        terms.append(Vsop87(A, B, C))
    else:
        # Otherwise, if S and/or K are nontrivial, convert them.
        if (abs(S) > 1e-15) or (abs(K) > 1e-15):
            R = math.hypot(S, K)  # sqrt(S^2 + K^2)
            alpha = math.atan2(S, K)  # conversion angle
            new_b = B - alpha
            terms.append(Vsop87(R, new_b, C))
    return terms

def generate_rust_arrays():
    """
    Walk through expansions and produce Rust array declarations.
    For each planet and for each coordinate (X, Y, Z) and each T-power, generate:
      pub static PLANET_COORDT: [Vsop87; N] = [ ... ];
    """
    lines = []
    # Iterate through planets in sorted order.
    for planet in sorted(expansions.keys()):
        planet_upper = planet.upper()
        # Map numeric coordinate to letter: 1 -> X, 2 -> Y, 3 -> Z.
        coord_map = {1: "X", 2: "Y", 3: "Z"}
        # We'll collect the names of all arrays for a planet (if needed later).
        all_coord_names = { 1: [], 2: [], 3: [] }
        for coord_i in sorted(expansions[planet].keys()):
            short_label = coord_map[coord_i]
            for t_power in sorted(expansions[planet][coord_i].keys()):
                arr_name = f"{planet_upper}_{short_label}{t_power}"
                Vsop87_list = expansions[planet][coord_i][t_power]
                lines.append(f"pub static {arr_name}: [Vsop87; {len(Vsop87_list)}] = [")
                for term in Vsop87_list:
                    lines.append(f"    {repr(term)},")
                lines.append("];\n")
                all_coord_names[coord_i].append(arr_name)
    return "\n".join(lines)

def main(input_filename, output_filename):
    """
    Parse the input Vsop87 file (version A) and write out a Rust source file
    containing static expansions for each planet.
    """
    current_planet = None
    current_coord = None
    current_tpower = None
    terms_remaining = 0

    with open(input_filename, "r") as f:
        for line in f:
            line = line.rstrip()
            if not line:
                continue

            # Check for a header line that defines the current block.
            m = header_re.search(line)
            if m:
                planet_name = m.group(1).upper()  # e.g., "VENUS"
                coord_index = int(m.group(2))      # 1 for X, 2 for Y, 3 for Z
                t_power     = int(m.group(3))      # T-power, e.g., 0..5
                n_terms     = int(m.group(4))      # Number of terms in this block

                current_planet = planet_name
                current_coord = coord_index
                current_tpower = t_power
                terms_remaining = n_terms

                ensure_path(current_planet, current_coord, current_tpower)
                continue

            # If we are in a block, parse each term line.
            if terms_remaining > 0 and current_planet is not None:
                parsed = parse_Vsop87_line(line)
                if parsed is None:
                    continue
                (S, K, A, B, C) = parsed
                final_terms = convert_sk_to_cos(S, K, A, B, C)
                expansions[current_planet][current_coord][current_tpower].extend(final_terms)
                terms_remaining -= 1

    # Generate Rust code from the collected expansions.
    rust_code = RUST_HEADER + "\n\n" + generate_rust_arrays()

    with open(output_filename, "w") as out:
        out.write(rust_code)

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} input_file output_file")
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])
